## JAVA并发
1. 并发与高并发
	1.  并发
		*  资源利用率、公平性、便利性
		* 多个线程操作相同资源，保证线程安全，合理使用资源 
		* 三要素：原子性、可见性、有序性
	2. 高并发：互联网分布式系统架构设计中必须考虑的因素之一，通过设计保证系统能够**同时并行处理**很多请求
		* 服务能同时处理很多请求，提高程序性能 
2. CPU多级缓存
	* 为什么需求CPU cache
		* CPU频率飞快，快到主存跟不上，所以在处理器时钟周期内，CPU需要等待主存，浪费资源。cache的出现，是为了缓解CPU和内存之间速度的不匹配问题 （cpu -> cache -> memory）
	* CPU cache有什么意义
		* 时间局部性：如果某个数据被访问，那么在不久的将来它很可能被再次访问  
		* 空间局部性：如果某个数据被访问，那么与它相邻的数据很快也可能被访问
	* CPU多级缓存-缓存一致性（MESI）
		* 用于保证多个CPU cache之间缓存共享数据的一致
	*  CPU多级缓存-乱序执行优化
		* 处理器为了提高运算速度而做出违背代码原来顺序的优化
3. `Java内存模型(*)`（Java Memory Model，JMM） 
	* Java内存模型-同步八种操作 
		* work=作用于工作内存的变量；main=作用于主内存的变量
		* lock（锁定）：$main把一个变量标识为一条线程独占状态
		* unlock（解锁）：$main把一个处于锁定状态的变量释放出来，释放出来的变量才可以被其他线程锁定
		* read（读取）：$main把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
		* load（载入）：$work它把read操作从主内存中得到的变量值放入工作内存的变量副本中
		* use（使用）：$work把工作内存中的一个变量值传递给执行引擎
		* assign（赋值）：$work它把一个从执行引擎接收到的值赋值给工作内存的变量
		* store（存储）：$work把工作内存中的一个变量的值传送到主内存中，以便随后的write操作
		* write（写入）：$main它把store操作从工作内存中一个变量的值传送到主内存的变量中
4. 线程安全性
	* 当多个线程访问某个类时，不管运行时环境采用`何种调度方式`或者这些进程将如何交替执行，并且在主调代码中`不需要任何额外的同步或协同`，这个类都能表现出`正确的行为`，那么就称这个类是线程安全的
	* 原子性：提供了互斥访问，同一时刻只能有一个线程来对它进行操作
		1.  `CAS（compare and swap）(*)`：比较并交换，其作用是让CPU比较内存中某个值是否和预期的值相同，如果相同则将这个值更新为新值，不相同则不做更新
			*  Atomic中的子方法 **Unsafe.compareAndSwapInt(Object var1, long var2, int var4, int var5)**：比较内存中的一个值和我们的期望值(var4)是否一样，如果一样则将内存中的这个值更新为var5，参数中的var1是值所在的对象，var2是值在对象(var1)中的内存偏移量，`参数var1和参数var2是为了定位出值所在内存的地址`
			*  CAS的ABA问题 ：线程1抢先获得CPU时间片，而线程2因为其他原因阻塞了，线程1取值与期望的A值比较，发现相等然后将值更新为B，然后这个时候出现了线程3，期望值为B，欲更新的值为A，线程3取值与期望的值B比较，发现相等则将值更新为A，此时线程2从阻塞中恢复，并且获得了CPU时间片，这时候线程2取值与期望的值A比较，发现相等则将值更新为B，虽然线程2也完成了操作，但是线程2并不知道值已经经过了A->B->A的变化过程
				* 版本号机制：取数据时获取当前version,更新时把version+1,如果version不对则更新失败 
		2. LongAdder：使用分散提高效率
		3. AtomicReference
		4. AtomicStampReference
		5. 原子性-锁
			* synchronized：依赖JVM
				* 修饰代码块：大括号括起来的代码，作用于调用的对象
				* 修饰方法：整个方法，作用于调用的对象
				* 修饰静态方法：整个静态方法，作用于所有对象
				* 修饰类：括号括起来的部分，作用于所有对象
			* Lock：ReentrantLock
		6. 原子性-对比
			* synchronized：不可中断锁，适合竞争不激烈，可读性好
			* Lock：可中断锁，多样化同步，竞争激烈时能维持常态
			* Atomic：竞争激烈时能维持常态，比Lock性能好；只能同步一个值
	* 可见性：一个线程对主内存的修改可以及时的被其它线程观察到
	* 有序性：一个线程观察其它线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序
	
	*******
	