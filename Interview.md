<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [剑指java offer](#%E5%89%91%E6%8C%87java-offer)
      - [计算机网络](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)
      - [数据库](#%E6%95%B0%E6%8D%AE%E5%BA%93)
      - [Redis](#redis)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 剑指java offer
#### 计算机网络

1. OSI七层协议:物理层->数据链路层->网络层->传输层->会话层->表示层->应用层
2. OSI的实现:TCP/IP四层模型
3. 传输控制协议TCP简介:
    * 面向连接的、可靠的、基于字节流的传输层通信协议
    * 将应用层的数据流分割成报文段并发送给目标节点的TCP层
    * 数据包都有序号,对方收到则发送ACK确认,未收到则重传
    * 使用校验和来校验数据在传输过程中是否有误
4. TCP的三次握手,握手是为了建立连接.
    * ACK:确认序号标志;SYN:同步序号,用于建立连接过程;FIN:finish标志,用于释放连接
    * 流程图如下:TCP协议提供可靠的连接服务,采用三次握手
    1. 第一次握手:建立连接时,客户端发送SYN包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认
    2. 第二次握手:服务器收到SYN包,必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包,此时服务器进入SYN_RECV状态
    3. 第三次握手:客户端收到服务器的SYN+ACK包,向服务器发送确认包(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手
    * 为什么需要三次握手才能建立起连接?
        * 为了初始化sequence number的初始值
    * 首次握手隐患--SYN超时的问题,即Server收到client的SYN,回复SYN-ACK时未收到ACK确认
        * Server不断重试直至超时,Linux默认等待63秒才断开连接(1,2,4,8,16,32五次,每次时间翻倍)
    * 建立连接后Client出现故障怎么办?
        * 保活机制:向对方发送保活探测报文,如果未收到响应则继续发送;尝试次数达到保活探测数仍未收到响应则中断连接
5. TCP的四次挥手,挥手是为了终止连接
    * 流程图如下:TCP采用四次挥手来释放连接
    1. 第一次挥手:Client发送一个FIN,用来关闭Client到Server的数据传送,Client进入FIN_WAIT_1状态
    2. 第二次挥手:Server收到FIN后,发送一个ACK给Client,确认序号为seq+1(与SYN相同),Server进入CLOSE_WAIT状态
    3. 第三次挥手:Server发送一个FIN,用来关闭Server到Client的数据传送,Server进入LAST_ACK状态
    4. 第四次挥手:Client收到FIN后,Client进入TIME_WAIT状态,接着发送一个ACK给Server,确认序号为收到序号+1,Server进入CLOSED状态,完成四次挥手
    * 为什么会有TIME_WAIT状态(等待2MSL时间)?
        * 确保有足够的时间让对方收到ACK包;避免新旧连接混淆
    * 为什么需要四次挥手才能断开连接?
        * 因为全双工(接收数据时亦可发送),发送方和接收方都需要FIN报文和ACK报文
    * 服务器出现大量CLOSE_WAIT状态的原因?
        * 对方关闭socket连接,我方忙于读或写,没有及时关闭连接;检查代码中是否释放资源和配置中处理请求的线程配置
* UDP简介
  * 面向非连接
  * 不维护连接状态,支持同时向多个客户端传输相同的消息
  * 数据包报头只有8个字节,额外开销较小
  * 吞吐量只受限于数据生成速率、传输速率以及机器性能
  * 尽最大努力交付,不保证可靠交付
  * 面向报文,不对应用程序提交的报文信息进行拆分或合并
  
* TCP和UDP区别
  * 面向连接vs无连接
  * 可靠性:可靠vs不保证可靠
  * 有序性:有序vs无序
  * 速度:慢vs快
  * 量级:重vs轻
  
* TCP的滑动窗口
  * RTT:发送一个数据包到收到对应的ACK所花费的时间;RTO:重传时间间隔
  * tcp使用滑动窗口做流量控制与乱序重排:保证可靠性和流控特性
  
* HTTP简介:超文本传输协议
  * 特点:支持C/S模式;简单快速;灵活;无连接;无状态
  * 请求/响应的步骤:
    1. 客户端连接到Web服务器
    2. 发送HTTP请求
    3. 服务器接受请求并返回HTTP响应
    4. 释放连接TCP连接
    5. 客户端浏览器解析HTML内容
  * 在浏览器地址栏输入URL回车后经历的流程
    * DNS解析->TCP连接->发送HTTP请求->服务器处理请求并返回HTTP报文->浏览器解析渲染页面->连接结束
  * HTTP状态码:
    * 1xx:指示信息--表示请求已接收,继续处理
    * 2xx:成功--表示请求已被成功接收、理解、接受
    * 3xx:重定向--要完成请求必须进行更进一步的操作
    * 4xx:客户端错误--请求有语法错误或无法实现
    * 5xx:服务器端错误--服务器未能实现合法的请求
  * 常见状态码:
    * 200 OK:正常返回信息
    * 400 Bad Request:客户端请求有语法错误,不能被服务器所理解
    * 401 Unauthorized:请求未经授权,状态代码必须和WWW.Authenticate报头域一起使用
    * 403 Forbidden:服务器收到请求,但拒绝提供服务
    * 404 Not Found:请求资源不存在
    * 500 Internal Server Error:服务器发生不可预期的错误
    * 503 Server Unavailable:服务器当前不能处理客户端的请求,一段时间后可能恢复正常
  
* GET请求和POST请求的区别

  * http报文层面:GET将请求信息放在URL中,POST放在请求体中
  * 数据库层面:GET符合幂等性和安全性,POST不符合
  * 其他层面:GET可以被缓存、被存储,而POST不行

* Cookie和Session的区别

  * Cookie数据存放在客户的浏览器上,Session数据放在服务器上
  * Session相对于Cookie更安全
  * 若考虑减轻服务器负担,应当使用Cookie

* HTTP和HTTPS的区别

  1. HTTPS需要到CA申请证书,HTTP不需要
  2. https密文传输,http明文传输
  3. 连接方式不同.https默认使用443端口,http使用80端口
  4. https=http+加密+认证+完整性保护,较http安全;http为无状态

  * SSL(安全套接层):
    * 为网络通信提供安全及数据完整性的一种安全协议
    * 是操作系统对外的API,SSL3.0后更名为TLS
    * 采用身份验证和数据加密保证网络通信的安全和数据的完整性
  * HTTPS数据传输流程
    * 浏览器将支持的加密算法信息发送给服务器
    * 服务器选择一套浏览器支持的加密算法,以证书的形式回发浏览器
    * 浏览器验证证书合法性,并结合证书公钥加密信息发送给服务器
    * 服务器使用私钥解密信息,验证哈希,加密响应消息回发浏览器
    * 浏览器解密响应消息,并对消息进行验真,之后进行加密交互数据

* Socket简介

  * socket是对tcp/ip协议的抽象,是操作系统对外开放的接口
  * socket通信流程
    * Server:创建socket(socket)->绑定端口号(bind)->监听(listen)->接收连接请求(accept)->从socket读取字符(recv)->关闭
    * Client:创建socket->连接指定端口(connect)->向socket写入信息(send)->关闭

#### 数据库

1. 如何设计一个关系性数据库?

   * 两大块:程序实例(存储管理、缓存机制、SQL解析、日志管理、权限划分、容灾机制、索引管理、锁管理)和存储(文件系统)

2. 为什么要使用索引？

   * 传统使用链表轮询所有的表,效率低;为了快速查询数据

3. B+Tree更适合做存储索引

   * 磁盘读写代价更低;查询效率更稳定;更利于对数据库的扫描

4. 如果用hash索引所存在的问题?

   1. 仅仅满足=和in,不能范围查询
   2. 无法被用来避免数据的排序
   3. 不能利用部分索引键查询
   4. 不能避免表扫描
   5. 大量Hash值相同时性能低下

5. 密集索引和稀疏索引的区别

    a.  密集索引文件中的每个搜索码值都对应一个索引值，其叶子节点保存不仅仅是键值，还保存了位于同一行记录里的其他列的信息，由于密集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能创建一个密集索引。innoDB

    b.  稀疏索引文件只为索引码的某些值建立索引项，其叶子节点仅保存了键位信息以及该行数据的地址或者主键。mylsam

6. 如何优化慢sql?

   * 根据慢日志定位慢sql语句(slow_query_log=on,long_query_time=1);show variables like '%query%';->使用explain分析sql;->修改sql或让sql走索引
   * explain关键字段
     * type:为index和all说明走的是全表扫描
     * extra:Using filesort表示对结果使用外部索引排序即文件排序;Using temporary表示对查询结果排序时使用临时表,常见于order by和group by.

7. 联合索引的最左匹配原则的成因?

   * 最左匹配原则:最左优先,会一直匹配到范围查询时停止,其中=和in可以乱序.如:a=3 and b>4 and c=5,如果联合索引为(a,b,c)则c用不到索引,若为(a,c,b)则都能用到.
   * 创建联合索引的规则是首先会对联合合索引的最左边的,也就是第一个字段col1的数据进行排序,在第一个字段的排序基础上,然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。

8. 为什么要使用联合索引?

   * 减少开销.建一个联合索引(col1,col2,col3),实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引.每多一个索引,都会增加写操作的开销和磁盘空间的开销.对于大量数据的表,使用联合索引会大大的减少开销.

   * **覆盖索引**.对联合索引(col1,col2,col3),如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据,而无需回表,这减少了很多的随机io操作.减少io操作,特别的随机io其实是dba主要的优化策略.所以,在真正的实际应用中,覆盖索引是主要的提升性能的优化手段之一.

   * **效率高**.索引列越多,通过索引筛选出的数据越少.

9. 索引是越多越好吗?

   * 数据量小的表不需要建立索引,建立会增加额外的索引开销
   * 数据变更需要维护索引,因此索引越多意味着维护成本越高
   * 索引越多意味着也需要更多的空间

10. MyISAM与InnoDB关于锁方面的区别是什么?

    * 表级锁:查询多行数据时,对整张表上锁,此时执行其它行的事务操作时仍需等待查询完成时解锁.
    * read锁(共享锁):;write锁(排它锁)

    1. MyISAM默认用的是表级锁,不支持行级锁
    2. InnoDB默认用的是行级锁,也支持表级锁

11. MyISAM和InnoDB适合的场景区别?

    1. 频繁执行全表count语句;对数据进行增删改的频率不高查询非常频繁;没有事务
    2. 数据增删改查都相当频繁;可靠性要求比较高,要求支持事务

12. 悲观锁与乐观锁?

    * 悲观锁:每次取数据时,都认为其它线程会修改数据,所以获取时都会先上锁.一旦上锁不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放.
      * mysql中的行锁,表锁,Java的synchronize
    * 乐观锁:每次获取数据时,认为不会有其它线程对数据进行修改,所以不会上锁,但在更新时会判断其他线程在这之前有没有对数据进行修改.**一般会使用`版本号机制`或`CAS(compare and swap)算法`实现**
      * 版本号机制:取数据时获取当前version,更新时把version+1,如果version不对则更新失败
      * CAS算法:当多个线程尝试使用CAS同时更新同一个变量时,只有其中一个线程能更新变量的值,而其它线程都失败,失败的线程并不会被挂起,而是被告知这次竞争中失败,并可以再次尝试
    * 读的多,冲突几率小,乐观锁。写的多,冲突几率大,悲观锁。

13. 事务的四大特性

    1. 原子性:要么不做,要么全做
    2. 一致性:从一个一致的操作到另一个一致操作
    3. 隔离性:多个事务并发执行,一个事务的执行不应该影响其它的事务
    4. 持久性:一个事务一旦提交,它的修改应该永久保存数据库中

14. 事务并发访问问题

    * | 事务隔离级别 | 更新丢失 | 脏读 | 不可重复读 | 幻读 |
      | :----------: | :------: | :--: | :--------: | :--: |
      |   未提交读   |   避免   | 发生 |    发生    | 发生 |
      | 已提交读(RC) |   避免   | 避免 |    发生    | 发生 |
      | 可重复读(RR) |   避免   | 避免 |    避免    | 发生 |
      |    串行化    |   避免   | 避免 |    避免    | 避免 |

15. next-key锁(行锁+gap锁)

    * gap锁:间隙锁,锁定一个范围,但不包括记录本身.GAP锁的目的,是为了防止同一事务的两次当前读,出现幻读的情况.
    * 对主键索引或唯一索引会用gap锁吗?
      * 如果where条件全部命中,则不会加gap锁只加记录锁;若部分命中或全不中,则会加gap锁.
    * gap锁会用在非唯一索引或不走索引的当前读中

#### Redis

1. 为什么redis能这么快?(100000+QPS每秒内查询次数)
   * 完全基于内存,绝不部分请求是纯粹的内存操作,执行效率高
   * 数据结构简单,对数据操作也简单
   * 采用单线程,单线程也能处理高并发请求,想多核也可启动多实例
   * 使用多路I/O复用模型,非阻塞IO
2. 数据类型及适用场景
   1. String:最基本的,二进制安全;适用于存图片,mysql字段,id自增
   2. Hash:String组成的字典;适合用于存储对象
   3. List:列表,按照插入顺序排序;适用于微博头条,消息队列
   4. Set:无序集合,通过哈希表实现,不允许重复;适用于共同好友,好友推荐,统计网站独立ip等
   5. Sorted Set:有序集合,通过分数为集合中的成员进行从小到大的排序;适用于带权重的元素,排行榜,成绩单等
3. 从海量Key里查询出某一固定前缀的Key
   1. (不可用的原因)keys pattern：查找所有符合给定模式pattern的Key
      * keys指令一次性返回所有匹配的key
      * 键的数量过大会使服务卡顿
   2. scan cursor [match pattern] [count i]
      * 基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程
      * 以0作为游标开始一次新的迭代,直到命令返回游标0完成一次遍历
      * 不保证每次执行都返回某个给定数量的元素,支持模糊查询
      * 一次返回的数量不可控,只能是大概率符合count参数
4. 如何通过Redis实现分别式锁?
   * 分布式锁需要解决的问题
     * 互斥性,安全性,死锁,容错
   * setnx key value:如果key不存在则创建并赋值;成功返回1.
     * expire key seconds:设置key的生存时间,过期则自动删除
   * set key value [ex seconds] [px milliseconds] [nx|xx]
     * ex|px:过期时间秒|毫秒;nx|xx:不存在时设置|存在时设置
   * 大量的key同时过期的注意事项
     * 问题:集中过期,由于清除大量的key很耗时,会出现短暂的卡顿现象
     * 解决方案:在设置key的过期时间时给每个key加上随机值
5. 如何使用Redis做异步队列?
   1. 使用List作为队列,rpush生产消息,lpop消费消息
      * 缺点:没有等待队列里有值就直接消费
      * 弥补:可以通过在应用层引入sleep机制去调用lpop重试
   2. blpop key timeout:阻塞直到队列有消息或超时
      * 缺点:只能供一个消费者消费
   3. pub/sub:主题订阅者模式
      * 发送者(pub)发送消息,订阅者(sub)接收消息
      * 订阅者可以订阅任意数量的频道
      * 缺点:无状态的,无法保证可达
6. Redis如何做持久化?
   * RDB(快照)持久化:保存某个时间点的全量数据快照
     * save:阻塞redis的服务器进程,直到RDB文件被创建完毕
     * bgsave:Fork出一个子进程来创建RDB文件,不阻塞服务器进程
     * 缺点:内存数据的全量同步,数据量大会由于I/O而严重影响性能;可能会因为redis挂掉而丢失从当前至最近一次快照期间的数据
   * 自动化触发RDB持久化的方式?
     * 根据redis.conf配置里的save m n定时触发(用的是bgsave)
     * 主从复制时,主节点自动触发
     * 执行Debug Reload
     * 执行Shutdown且没有开启AOF持久化
   * AOP持久化:保存写状态
     * 记录下吃了查询以外的所有变更数据库状态的指令
     * 以append形式追加保存至AOP文件中(增量)
   * 日志重写解决AOP文件大小不断增大的问题
     * 调用fork(),创建一个子进程
     * 子进程把新的AOF写到一个临时文件里,不依赖原来的AOF文件
     * 主进程持续将新的变动同时写到内存和原来的AOF里
     * 主进程获取子进程重写AOF的完成信号,往新AOF同步增量变动
     * 使用新的AOF文件替换掉旧的AOF文件
   * Redis数据的恢复
     * 先搜索是否存在AOF,再搜索RDB
   * RDB和AOF的优缺点
     * RDB:全量数据快照,文件小,恢复快;无法保存最近一次快照之后的数据
     * AOF:可读性高,适合保存增量数据,数据不易丢失;文件体积大,恢复时间长
     * 混合持久化:BGSAVE做镜像全量持久化,AOF做增量持久化
   * 使用Pipeline的好处
     * Pipeline和Linux的管道类似
     * Redis基于请求/响应模型,单个请求处理需要一一应答
     * Pipeline批量执行指令,节省多次IO往返的时间
     * 有顺序依赖的指令建议分批发送

1. 对一组数据进行排序？
   1. 有没有可能包含有大量重复元素？-> 三路快排
   2. 是否大部分数据距离它正确的位置很近？近乎有序？-> 插入排序
   3. 是否数据的取值范围非常有限？比如学生成绩排序 -> 计数排序
   4. 是否需要稳定排序？-> 归并排序
   5. 是否是使用链表存储的？ -> 归并排序
   6. 数据的大小是否可以装载在内存里？ -> 外排序

