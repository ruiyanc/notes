### Shell脚本
1. 第一行声明 #!/bin/sh
2. 变量
    * 使用变量需加$
    * 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变
    * 使用 unset 命令可以删除变量
    * 字符串双引号""可以有变量，\转义字符
    * echo ${#str}  -> 获取字符串的长度
    * echo ${string:\m:n} -> 从第m+1个字符开始截取n个字符
    * echo \`expr index "$string" io\`  -> 查找字符i或o的位置
3. 数组
    * 定义数组 -> 用括号来表示数组，数组元素用"空格"符号分割开 ->数组名=(值1 值2 ... 值n)
    * 读取数组 -> \${数组名[下标]}   用 @ 符号可以获取数组中的所有元素-> echo ${array_name[@]}
4. 注释
    * 以#开头的行就是注释
    * 多行注释   :<<! 注释内容... !
5. 传参
    * 脚本内获取参数为：$n ,  $0 为执行的文件名
    * \$#    传递到脚本的参数个数
    * \$*    以一个单字符串显示所有向脚本传递的参数。
    * \$$    脚本运行的当前进程ID号
    * \$!    后台运行的最后一个进程的ID号
    * \$@    与$*相同，但是使用时加引号，并在引号中返回每个参数。
    * \$-    显示Shell使用的当前选项，与set命令功能相同。
    * \$?    显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。
    * \$* 与 $@ 区别：
        * 相同点：都是引用所有参数。
        * 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 " * " 等价于 "1 2 3"（传递了一个参数），而 "@" 等价于 "1" "2" "3"（传递了三个参数）
6. 中括号条件
    * 算术比较, 比如一个变量是否为0, [ $var -eq 0 ]。
    * 文件属性测试，比如一个文件是否存在，[ -e $var ], 是否是目录，[ -d $var ]。
    * 字符串比较, 比如两个字符串是否相同， [[ $var1 = $var2 ]]
7. 运算符
    * expr进行运算，表达式和运算符之间要有空格，完整的表达式要被\` \` 包含。比如 \`expr $a + $b`
    * 数字的关系运算符
        * -eq 相等，-ne 不等， -gt 大于，-lt 小于，!非运算，-o或，-a与
    * 字符串运算符
        * =相等，!=不等，-z长度是否为0，-n是否不为0，$字符串是否为空
    * 文件测试运算符
        * -b 是否块设备文件，-c 字符设备文件，-d 目录，-f 普通文件，-g 是否设置了SGID位，-k 设置粘着位，-p 是否是有名管道，-s 是否为空，-e 是否存在，-rwx 读写执行
8. echo命令 -> 用于字符串的输出
    * read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量
    * 显示结果定向至文件 --> \echo "It is a test" > myfile
    * 单引号原样输出字符串
9. test命令  -> 检查某个条件是否成立
    * 文件测试
      * -e filename 如果文件存在则为真，rwx读写执行，-s存在且至少有一个字符，-d目录，-f普通文件，-c字符型特殊文件，-b块特殊文件
10. 流程控制
    * 条件判断：\if [ $(ps -ef | grep -c "ssh") -gt 1 ]; then echo "true"; fi
    * for循环：\for var in item1 item2 ... itemN; do command1; command2… done;
    * while 循环用于不断执行一系列命令，也用于从输入文件中读取数据 
11. shell函数
     * 定义函数 [ function  ] funname [ ( ) ]  { action;  [return int;] }
     * 函数返回值在调用该函数后通过 $? 来获得
     * 函数放在脚本开始部分进行定义
12. shell输入输出重定向
     * 文件描述符 0 通常是标准输入(STDIN)，1是标准输出(STDOUT)，2是标准错误输出(STDERR)
     * command > file输出重定向，n > file将文件描述符为 n 的文件重定向到 file，>>追加
     * 如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null.  -> command > /dev/null 2>&1
13. 文件包含
     * 引用外部脚本 --> .filename 或 source filename
