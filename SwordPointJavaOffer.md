<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [剑指java offer](#%E5%89%91%E6%8C%87java-offer)
      - [计算机网络](#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)
      - [数据库](#%E6%95%B0%E6%8D%AE%E5%BA%93)
      - [Redis](#redis)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

## 剑指java offer
#### 计算机网络

1. OSI七层协议:物理层->数据链路层->网络层->传输层->会话层->表示层->应用层
2. OSI的实现:TCP/IP四层模型
3. 传输控制协议TCP简介:
    * 面向连接的、可靠的、基于字节流的传输层通信协议
    * 将应用层的数据流分割成报文段并发送给目标节点的TCP层
    * 数据包都有序号,对方收到则发送ACK确认,未收到则重传
    * 使用校验和来校验数据在传输过程中是否有误
4. TCP的三次握手,握手是为了建立连接.
    * ACK:确认序号标志;SYN:同步序号,用于建立连接过程;FIN:finish标志,用于释放连接
    * 流程图如下:TCP协议提供可靠的连接服务,采用三次握手
        1. 第一次握手:建立连接时,客户端发送SYN包(syn=j)到服务器,并进入SYN_SEND状态,等待服务器确认
        2. 第二次握手:服务器收到SYN包,必须确认客户的SYN(ack=j+1),同时自己也发送一个SYN包(syn=k),即SYN+ACK包,此时服务器进入SYN_RECV状态
        3. 第三次握手:客户端收到服务器的SYN+ACK包,向服务器发送确认包(ack=k+1),此包发送完毕,客户端和服务器进入ESTABLISHED状态,完成三次握手
    * 为什么需要三次握手才能建立起连接?
        * 为了初始化sequence number的初始值
    * 首次握手隐患--SYN超时的问题,即Server收到client的SYN,回复SYN-ACK时未收到ACK确认
        * Server不断重试直至超时,Linux默认等待63秒才断开连接(1,2,4,8,16,32五次,每次时间翻倍)
    * 建立连接后Client出现故障怎么办?
        * 保活机制:向对方发送保活探测报文,如果未收到响应则继续发送;尝试次数达到保活探测数仍未收到响应则中断连接
5. TCP的四次挥手,挥手是为了终止连接
    * 流程图如下:TCP采用四次挥手来释放连接
        1. 第一次挥手:Client发送一个FIN,用来关闭Client到Server的数据传送,Client进入FIN_WAIT_1状态
        2. 第二次挥手:Server收到FIN后,发送一个ACK给Client,确认序号为seq+1(与SYN相同),Server进入CLOSE_WAIT状态
        3. 第三次挥手:Server发送一个FIN,用来关闭Server到Client的数据传送,Server进入LAST_ACK状态
        4. 第四次挥手:Client收到FIN后,Client进入TIME_WAIT状态,接着发送一个ACK给Server,确认序号为收到序号+1,Server进入CLOSED状态,完成四次挥手
    * 为什么会有TIME_WAIT状态(等待2MSL时间)?
        * 确保有足够的时间让对方收到ACK包;避免新旧连接混淆
    * 为什么需要四次挥手才能断开连接?
        * 因为全双工(接收数据时亦可发送),发送方和接收方都需要FIN报文和ACK报文
    * 服务器出现大量CLOSE_WAIT状态的原因?
        * 对方关闭socket连接,我方忙于读或写,没有及时关闭连接;检查代码中是否释放资源和配置中处理请求的线程配置
    * [Tcp握手与挥手图](https://github.com/ruiyanc/images/blob/main/Tcp.png)
* UDP简介
  * 面向非连接
  * 不维护连接状态,支持同时向多个客户端传输相同的消息
  * 数据包报头只有8个字节,额外开销较小
  * 吞吐量只受限于数据生成速率、传输速率以及机器性能
  * 尽最大努力交付,不保证可靠交付
  * 面向报文,不对应用程序提交的报文信息进行拆分或合并
  
* TCP和UDP区别
  * 面向连接vs无连接
  * 可靠性:可靠vs不保证可靠
  * 有序性:有序vs无序
  * 速度:慢vs快
  * 量级:重vs轻
  
* TCP的滑动窗口
  * RTT:发送一个数据包到收到对应的ACK所花费的时间;RTO:重传时间间隔
  * tcp使用滑动窗口做流量控制与乱序重排:保证可靠性和流控特性
  
* HTTP简介:超文本传输协议
  * 特点:支持C/S模式;简单快速;灵活;无连接;无状态
  * 请求/响应的步骤:
    1. 客户端连接到Web服务器
    2. 发送HTTP请求
    3. 服务器接受请求并返回HTTP响应
    4. 释放连接TCP连接
    5. 客户端浏览器解析HTML内容
  * 在浏览器地址栏输入URL回车后经历的流程
    * DNS解析->TCP连接->发送HTTP请求->服务器处理请求并返回HTTP报文->浏览器解析渲染页面->连接结束
  * HTTP状态码:
    * 1xx:指示信息--表示请求已接收,继续处理
    * 2xx:成功--表示请求已被成功接收、理解、接受
    * 3xx:重定向--要完成请求必须进行更进一步的操作
    * 4xx:客户端错误--请求有语法错误或无法实现
    * 5xx:服务器端错误--服务器未能实现合法的请求
  * 常见状态码:
    * 200 OK:正常返回信息
    * 400 Bad Request:客户端请求有语法错误,不能被服务器所理解
    * 401 Unauthorized:请求未经授权,状态代码必须和WWW.Authenticate报头域一起使用
    * 403 Forbidden:服务器收到请求,但拒绝提供服务
    * 404 Not Found:请求资源不存在
    * 500 Internal Server Error:服务器发生不可预期的错误
    * 503 Server Unavailable:服务器当前不能处理客户端的请求,一段时间后可能恢复正常
  
* GET请求和POST请求的区别

  * http报文层面:GET将请求信息放在URL中,POST放在请求体中
  * 数据库层面:GET符合幂等性和安全性,POST不符合
  * 其他层面:GET可以被缓存、被存储,而POST不行

* Cookie和Session的区别

  * Cookie数据存放在客户的浏览器上,Session数据放在服务器上
  * Session相对于Cookie更安全
  * 若考虑减轻服务器负担,应当使用Cookie

* HTTP和HTTPS的区别

  1. HTTPS需要到CA申请证书,HTTP不需要
  2. https密文传输,http明文传输
  3. 连接方式不同.https默认使用443端口,http使用80端口
  4. https=http+加密+认证+完整性保护,较http安全;http为无状态

  * SSL(安全套接层):
    * 为网络通信提供安全及数据完整性的一种安全协议
    * 是操作系统对外的API,SSL3.0后更名为TLS
    * 采用身份验证和数据加密保证网络通信的安全和数据的完整性
  * HTTPS数据传输流程
    * 浏览器将支持的加密算法信息发送给服务器
    * 服务器选择一套浏览器支持的加密算法,以证书的形式回发浏览器
    * 浏览器验证证书合法性,并结合证书公钥加密信息发送给服务器
    * 服务器使用私钥解密信息,验证哈希,加密响应消息回发浏览器
    * 浏览器解密响应消息,并对消息进行验真,之后进行加密交互数据

* Socket简介
  * socket是对tcp/ip协议的抽象,是操作系统对外开放的接口
  * socket通信流程
    * Server:创建socket(socket)->绑定端口号(bind)->监听(listen)->接收连接请求(accept)->从socket读取字符(recv)->关闭
    * Client:创建socket->连接指定端口(connect)->向socket写入信息(send)->关闭

#### 数据库

1. 如何设计一个关系性数据库?

   * 两大块:程序实例(存储管理、缓存机制、SQL解析、日志管理、权限划分、容灾机制、索引管理、锁管理)和存储(文件系统)

2. 为什么要使用索引？

   * 传统使用链表轮询所有的表,效率低;为了快速查询数据

3. B+Tree更适合做存储索引

   * 磁盘读写代价更低;查询效率更稳定;更利于对数据库的扫描

4. 如果用hash索引所存在的问题?

   1. 仅仅满足=和in,不能范围查询
   2. 无法被用来避免数据的排序
   3. 不能利用部分索引键查询
   4. 不能避免表扫描
   5. 大量Hash值相同时性能低下

5. 密集索引和稀疏索引的区别

    a.  密集索引文件中的每个搜索码值都对应一个索引值，其叶子节点保存不仅仅是键值，还保存了位于同一行记录里的其他列的信息，由于密集索引决定了表的物理排列顺序，一个表只能有一个物理排列顺序，所以一个表只能创建一个密集索引。innoDB

    b.  稀疏索引文件只为索引码的某些值建立索引项，其叶子节点仅保存了键位信息以及该行数据的地址或者主键。mylsam

6. 如何优化慢sql?

   * 根据慢日志定位慢sql语句(slow_query_log=on,long_query_time=1);show variables like '%query%';->使用explain分析sql;->修改sql或让sql走索引
   * explain关键字段
     * type:为index和all说明走的是全表扫描
     * extra:Using filesort表示对结果使用外部索引排序即文件排序;Using temporary表示对查询结果排序时使用临时表,常见于order by和group by.

7. 联合索引的最左匹配原则的成因?

   * 最左匹配原则:最左优先,会一直匹配到范围查询时停止,其中=和in可以乱序.如:a=3 and b>4 and c=5,如果联合索引为(a,b,c)则c用不到索引,若为(a,c,b)则都能用到.
   * 创建联合索引的规则是首先会对联合合索引的最左边的,也就是第一个字段col1的数据进行排序,在第一个字段的排序基础上,然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。

8. 为什么要使用联合索引?

   * 减少开销.建一个联合索引(col1,col2,col3),实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引.每多一个索引,都会增加写操作的开销和磁盘空间的开销.对于大量数据的表,使用联合索引会大大的减少开销.

   * **覆盖索引**.对联合索引(col1,col2,col3),如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据,而无需回表,这减少了很多的随机io操作.减少io操作,特别的随机io其实是dba主要的优化策略.所以,在真正的实际应用中,覆盖索引是主要的提升性能的优化手段之一.

   * **效率高**.索引列越多,通过索引筛选出的数据越少.

9. 索引是越多越好吗?

   * 数据量小的表不需要建立索引,建立会增加额外的索引开销
   * 数据变更需要维护索引,因此索引越多意味着维护成本越高
   * 索引越多意味着也需要更多的空间

10. MyISAM与InnoDB关于锁方面的区别是什么?

    * 表级锁:查询多行数据时,对整张表上锁,此时执行其它行的事务操作时仍需等待查询完成时解锁.
    * read锁(共享锁):;write锁(排它锁)

    1. MyISAM默认用的是表级锁,不支持行级锁
    2. InnoDB默认用的是行级锁,也支持表级锁

11. MyISAM和InnoDB适合的场景区别?

    1. 频繁执行全表count语句;对数据进行增删改的频率不高查询非常频繁;没有事务
    2. 数据增删改查都相当频繁;可靠性要求比较高,要求支持事务

12. 悲观锁与乐观锁?

    * 悲观锁:每次取数据时,都认为其它线程会修改数据,所以获取时都会先上锁.一旦上锁不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放.
      * mysql中的行锁,表锁,Java的synchronize
    * 乐观锁:每次获取数据时,认为不会有其它线程对数据进行修改,所以不会上锁,但在更新时会判断其他线程在这之前有没有对数据进行修改.**一般会使用`版本号机制`或`CAS(compare and swap)算法`实现**
      * 版本号机制:取数据时获取当前version,更新时把version+1,如果version不对则更新失败
      * CAS算法:当多个线程尝试使用CAS同时更新同一个变量时,只有其中一个线程能更新变量的值,而其它线程都失败,失败的线程并不会被挂起,而是被告知这次竞争中失败,并可以再次尝试
    * 读的多,冲突几率小,乐观锁。写的多,冲突几率大,悲观锁。

13. 事务的四大特性

    1. 原子性:要么不做,要么全做
    2. 一致性:从一个一致的操作到另一个一致操作
    3. 隔离性:多个事务并发执行,一个事务的执行不应该影响其它的事务
    4. 持久性:一个事务一旦提交,它的修改应该永久保存数据库中

14. 事务并发访问问题

    * | 事务隔离级别 | 更新丢失 | 脏读 | 不可重复读 | 幻读 |
      | :----------: | :------: | :--: | :--------: | :--: |
      |   未提交读   |   避免   | 发生 |    发生    | 发生 |
      | 已提交读(RC) |   避免   | 避免 |    发生    | 发生 |
      | 可重复读(RR) |   避免   | 避免 |    避免    | 发生 |
      |    串行化    |   避免   | 避免 |    避免    | 避免 |

15. next-key锁(行锁+gap锁)

    * gap锁:间隙锁,锁定一个范围,但不包括记录本身.GAP锁的目的,是为了防止同一事务的两次当前读,出现幻读的情况.
    * 对主键索引或唯一索引会用gap锁吗?
      * 如果where条件全部命中,则不会加gap锁只加记录锁;若部分命中或全不中,则会加gap锁.
    * gap锁会用在非唯一索引或不走索引的当前读中

#### Redis

1. 为什么redis能这么快?(100000+QPS每秒内查询次数)
   * 完全基于内存,绝不部分请求是纯粹的内存操作,执行效率高
   * 数据结构简单,对数据操作也简单
   * 采用单线程,单线程也能处理高并发请求,想多核也可启动多实例
   * 使用多路I/O复用模型,非阻塞IO
2. 数据类型及适用场景
   1. String:最基本的,二进制安全;适用于存图片,mysql字段,id自增
   2. Hash:String组成的字典;适合用于存储对象
   3. List:列表,按照插入顺序排序;适用于微博头条,消息队列
   4. Set:无序集合,通过哈希表实现,不允许重复;适用于共同好友,好友推荐,统计网站独立ip等
   5. Sorted Set:有序集合,通过分数为集合中的成员进行从小到大的排序;适用于带权重的元素,排行榜,成绩单等
3. 从海量Key里查询出某一固定前缀的Key
   1. (不可用的原因)keys pattern：查找所有符合给定模式pattern的Key
      * keys指令一次性返回所有匹配的key
      * 键的数量过大会使服务卡顿
   2. scan cursor [match pattern] [count i]
      * 基于游标的迭代器,需要基于上一次的游标延续之前的迭代过程
      * 以0作为游标开始一次新的迭代,直到命令返回游标0完成一次遍历
      * 不保证每次执行都返回某个给定数量的元素,支持模糊查询
      * 一次返回的数量不可控,只能是大概率符合count参数
4. 如何通过Redis实现分别式锁?
   * 分布式锁需要解决的问题
     * 互斥性,安全性,死锁,容错
   * setnx key value:如果key不存在则创建并赋值;成功返回1.
     * expire key seconds:设置key的生存时间,过期则自动删除
   * set key value [ex seconds] [px milliseconds] [nx|xx]
     * ex|px:过期时间秒|毫秒;nx|xx:不存在时设置|存在时设置
   * 大量的key同时过期的注意事项
     * 问题:集中过期,由于清除大量的key很耗时,会出现短暂的卡顿现象
     * 解决方案:在设置key的过期时间时给每个key加上随机值
5. 如何使用Redis做异步队列?
   1. 使用List作为队列,rpush生产消息,lpop消费消息
      * 缺点:没有等待队列里有值就直接消费
      * 弥补:可以通过在应用层引入sleep机制去调用lpop重试
   2. blpop key timeout:阻塞直到队列有消息或超时
      * 缺点:只能供一个消费者消费
   3. pub/sub:主题订阅者模式
      * 发送者(pub)发送消息,订阅者(sub)接收消息
      * 订阅者可以订阅任意数量的频道
      * 缺点:无状态的,无法保证可达
6. Redis如何做持久化?
   * RDB(快照)持久化:保存某个时间点的全量数据快照
     * save:阻塞redis的服务器进程,直到RDB文件被创建完毕
     * bgsave:Fork出一个子进程来创建RDB文件,不阻塞服务器进程
     * 缺点:内存数据的全量同步,数据量大会由于I/O而严重影响性能;可能会因为redis挂掉而丢失从当前至最近一次快照期间的数据
   * 自动化触发RDB持久化的方式?
     * 根据redis.conf配置里的save m n定时触发(用的是bgsave)
     * 主从复制时,主节点自动触发
     * 执行Debug Reload
     * 执行Shutdown且没有开启AOF持久化
   * AOP持久化:保存写状态
     * 记录下吃了查询以外的所有变更数据库状态的指令
     * 以append形式追加保存至AOP文件中(增量)
   * 日志重写解决AOP文件大小不断增大的问题
     * 调用fork(),创建一个子进程
     * 子进程把新的AOF写到一个临时文件里,不依赖原来的AOF文件
     * 主进程持续将新的变动同时写到内存和原来的AOF里
     * 主进程获取子进程重写AOF的完成信号,往新AOF同步增量变动
     * 使用新的AOF文件替换掉旧的AOF文件
   * Redis数据的恢复
     * 先搜索是否存在AOF,再搜索RDB
   * RDB和AOF的优缺点
     * RDB:全量数据快照,文件小,恢复快;无法保存最近一次快照之后的数据
     * AOF:可读性高,适合保存增量数据,数据不易丢失;文件体积大,恢复时间长
     * 混合持久化:BGSAVE做镜像全量持久化,AOF做增量持久化
   * 使用Pipeline的好处
     * Pipeline和Linux的管道类似
     * Redis基于请求/响应模型,单个请求处理需要一一应答
     * Pipeline批量执行指令,节省多次IO往返的时间
     * 有顺序依赖的指令建议分批发送
7. Redis的同步机制
	1. 全同步过程
		1. Salve发送sync命令到Master
		2. Master启动一个后台进程，将Redis中的数据快照保存到文件中
		3. Master将保存数据快照期间接收到的写命令缓存起来
		4. Master完成写文件操作后，将该文件发送给Salve
		5. 使用新的AOF文件替换掉旧的AOF文件
		6. Master将这期间收集的增量写命令发送给Salve端
	2. 增量同步过程
		1. Master接收到用户的操作指令，判断是否需要传播到Slave
		2. 将操作记录追加到AOF文件
		3. 将操作传播到其它Slave
			1. 对齐主从库
			2. 往响应缓存写入指令
		4. 将缓存中的数据发送给Slave 	
	3. Redis Sentinel
		*  解决主从同步Master宕机后的主从切换问题
		1. 监控：检查主从服务器是否运行正常
		2. 提醒：通过API向管理员或其它应用程序发送故障通知
		3. 自动故障迁移：主从切换
	4. 流言协议Gossip
		* 在杂乱无章中寻求一致
		* 每个节点都随机地与对方通信，最终所有节点的状态达成一致
		* 种子节点定期随机向其他节点发送节点列表以及需要传播的消息
		* 不保证信息一点回传递给所有节点，但最终会趋于一致
8. Redis集群
	1. Redis集群原理
		* 如果从海量数据里快速找到所需？
			* 分片：按照某种规则去划分数据，分散存储在多个节点上
			* 常规的按照哈希划分无法实现节点的动态增删
		* 一致性哈希算法：对2^32取模，将哈希值空间组织称虚拟的圆环
			* Hash环的数据倾斜问题
			* 引入虚拟节点解决数据倾斜的问题

#### Linux	

1. Linux的体系结构
	* 体系结构主要分为用户态（用户上层活动）和内核态
	* 内核：本质是一段管理计算机硬件设备的程序
	* 系统调用：内核的访问接口，是一种能再简化的操作
	* 公用函数库：系统调用的封装
	* Shell：命令解释器，可编程
2. 如何查找特定的文件
	* `find`：在指定目录下查找文件
		* -i：忽略大小写
3. 如何检索文件内容
	* `grep`：查找文件里符合条件的字符串
		* -o：正则筛选
		* -v：过滤
	* ps -ef | grep java | grep -v "grep"
	* 管道符|
		* 只处理前一个命令正确输出，不处理错误输出
		* 右边命令必须能够接收标准输入流，否则传递过程中数据会被抛弃
		* sed,awk,grep,cut,head,top,less,more,wc,join,sort,split等
4. 如何对文件内容做统计
	* `awk`：一次读取一行文本，按输入分隔符进行切片，切成多个组成部分
		* -F：以某符号作为分割符
	* 将切片直接保存在内建的变量中，$1,$2...($0表示行的全部)
	* 支持对单个切片的判断，支持循环判断，默认分隔符为空格
	* awk '{print $1,$4}' xx.txt ->打印出第一行和第四行的内容
	* awk '$1=="tcp" && $2==1 {print $0}' -> 满足第一行=tcp，第二行=1打印出所有内容
	* awk '{earr[$1]++}END{for(i in earr) print i "\t" earr[i]}' -> 统计某内容在文本中出现次数
5. 批量替换文件内容
	* `sed`：适合用于对文本的行内容进行处理
		* -i：替换文本的内容并回写
	* sed -i 's/\.$/\;/' xx.txt -> 把文本中以结尾.替换为;
	* sed -i 's/Jack/me/g' xx.txt -> 把文本所有中的Jack替换为me
	* sed -i 's/^ *$/d' -> 删除文本中的所有空行

#### JVM

1. 谈谈你对Java的理解
    * 平台无关性
        * Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换为具体平台上的机器指令
        * 为什么JVM不直接将源码解析成机器码去执行
            * 准备工作：每次执行都需要各种检查
            * 兼容性：也可以将别的语言解析成字节码
        * JVM如何加载.class文件
            * JVM虚拟机
                * Class Loader:依据特定格式加载class文件到内存
                * Execution Engine:对命令进行解析
                * Native Interface:融合不同开发语言的原生库为Java所用
                * Runtime Data Area:JVM内存空间结构模型
            * 反射
                * Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性;这种动态获取信息以及动态调用对象方法的功能称为Java反射机制
    * /GC/语言特性/面向对象/类库/异常处理
    * GC
    	* 如何识别垃圾
    		* 标记计数法
	    		* 有引用就计数若计数为0则为垃圾清除	
	    		* 缺点：循坏引用的垃圾无法回收
    		* 根可达性算法
	    		* 从根root出发查看所有引用，若没引用则为垃圾
	* GC回收算法
		* 标记清除（Mark-Sweep）
			* 识别为垃圾则进行标记来清除
			* 缺点：碎片化严重
		* 拷贝（Copying）
			* 把有用的部分复制到另一个地方暂存，然后清除原有部分
			* 缺点：浪费内存
		* 标记复制（Mark-Compact）
			* 标记并整理空间
			* 缺点：效率低
	* 分代回收算法 -> 把内存分为新生代和老年代，新建的对象在新生代里的eden伊甸区和两块survivor区，空间分为8:1:1，每次在eden区进行垃圾清理能清除90%的垃圾（比如for循环里的new对象操作），然后Copying没被回收的到survivor区暂存，第二次eden清除把剩下的移至另一块survivor区，并把eden和上一次的survivor区清除，循环往返操作。每次没被回收则年龄+1，到达某阈值则复制到老年代里
		* 新生代 -> Copying
		* 老年代 -> Mark-Compact
		* ParNew
	* GC演化过程
		* 几M到几十M -> Serial算法 单线程STW（stop the world）垃圾回收新生代老年代
		* 几十M到几百M/1G -> Parallel并行多线程STW

#### 多线程

1. 进程和线程
    * 概念
        * 进程是资源分配的最小单位，线程是CPU调度的最小单位
        * 所有与进程相关的资源，都被记录在PCB中
        * 进程是抢占处理机的调度单位，线程属于某个进程共享其资源
        * 线程只由堆栈寄存器、程序计数器和TCP组成
    * 区别
        * 线程不能看做独立应用，而进程可看做独立应用
        * 进程有独立的地址空间互不影响，线程只是进程的不同执行路径
        * 线程没有独立的地址空间，多进程的程序比多线程健壮
        * 进程的切换比线程的切换开销大
2. Thread的start和run方法的区别
    1. 调用start()方法会创建一个新的子线程并启动
    2. run()方法只是Thread的一个普通方法的调用
3. Thread和Runnable是什么关系
    * Thread是实现了Runnable接口的类，使得run支持多线程
    * 因类的单一继承原则，推荐多使用Runnable接口
4. 如何实现处理线程的返回值
    * 主线程等待法
    * 使用Thread类的join()阻塞当前线程以等待子线程处理完毕
    * 通过Callable接口实现：通过FutureTask或线程池获取
5. 线程的状态
    1. 新建(New):创建后尚未启动的线程的状态
    2. 运行(Runnable):包含Running和Ready
    3. 无限等待(Waiting):不会被分配CPU执行时间，需要显式被唤醒
        * 没有设置Timeout参数的Object.wait()或Thread.join()
        * LockSupport.park()方法
    4. 限期等待(Time Waiting):在一定时间后会由系统自动唤醒
        * Thread.sleep()
        * 设置Timeout参数的Object.wait()或Thread.join()
        * LockSupport.parkNanos()
        * LockSupport.parkUntil()
    5. 阻塞(Blocked):等待获取排它锁
    6. 结束(Terminated):已终止线程的状态，线程已经结束执行
6. sleep和wait的区别
    1. 基本区别
        * sleep是Thread类的方法，wait是Object类中定义的方法
        * sleep()方法可以在任何地方使用
        * wait()方法只能在synchronized方法或synchronized块中使用
    2. 本质区别
        * Thread.sleep只会让出CPU，不会导致锁行为的改变
        * Object.wait不仅让出CPU，还会释放已经占有的同步资源锁
7. notify和notifyAll的区别
    1. 锁池EntryList
        * 线程所需要被占用对象的锁拥有权而进入阻塞状态，进去某个地方等待锁的释放，这个地方便是该对象的锁池
    2. 等待池WaitSet
        * 线程A调用某个对象的wait(),就会释放该对象的锁，同时线程A进入该对象的等待池中，进入等待池中的线程不会去竞争该对象的锁
    3. notifyAll会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会
    4. notify只会随机选取一个处于等待池中的线程进去锁池去竞争获取锁的机会
8. yield
    * 当调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示，但线程调度器可能会不理睬
9. 如何中断线程
    1. 调用stop()方法停止线程（**废弃的方法**）
    2. 调用interrupt()通知线程应该中断了
10. Synchronized
	1. 线程安全问题的主要诱因
		* 存在共享数据（也称为临界资源）
		* 存在多条线程共同操作这些共享数据
		* 解决问题的根本方法
			* 同一时刻有且只有一个线程在操作共享数据，其它线程必须等到该线程处理完数据后再对共享数据进行操作
	2. 互斥锁的特性
		* 互斥性：即在同一时间只允许一个线程持有某个对象锁，从而实现多线程的协调机制，这样在同一时间只有一个线程对需要同步的代码块(复合操作)进行访问。也称为操作的原子性
		* 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获取该锁的另一个线程是可见的（即在获取锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致。
	* Synchronized锁的不是代码，锁的都是对象
        


***
1. 对一组数据进行排序？
   1. 有没有可能包含有大量重复元素？-> 三路快排
   2. 是否大部分数据距离它正确的位置很近？近乎有序？-> 插入排序
   3. 是否数据的取值范围非常有限？比如学生成绩排序 -> 计数排序
   4. 是否需要稳定排序？-> 归并排序
   5. 是否是使用链表存储的？ -> 归并排序
   6. 数据的大小是否可以装载在内存里？ -> 外排序

